from Crypto.Util.number import long_to_bytes
import decimal

decimal.setcontext(decimal.Context(prec=2000))

def find_invpow(x,n):
    high = 1
    while high ** n < x:
        high *= 2
    low = high//2
    while low < high:
        mid = (low + high) // 2
        if low < mid and mid**n < x:
            low = mid
        elif high > mid and mid**n > x:
            high = mid
        else:
            return mid
    return mid + 1

def inv(a, m) :  
      
    m0 = m  
    x0 = 0
    x1 = 1
  
    if (m == 1) :  
        return 0
    while (a > 1) :
        q = a // m  
  
        t = m  
        m = a % m  
        a = t  
  
        t = x0  
  
        x0 = x1 - q * x0  
  
        x1 = t  
    if (x1 < 0) :  
        x1 = x1 + m0  
  
    return x1  
  

def findMinX(num, rem, k) :  
      
    # Compute product of all numbers  
    prod = 1
    for i in range(0, k) :  
        prod = prod * num[i]  
  
    # Initialize result  
    result = 0
  
    # Apply above formula  
    for i in range(0,k):  
        pp = prod // num[i]  
        result = result + rem[i] * inv(pp, num[i]) * pp  
      
      
    return result % prod

# Driver method  
num = [0, 0, 0]  
rem = [0, 0, 0]  
k = 3

#put the first modulus here
num[0] = 131908813036851855556617106358045477064620329829877608189512978162690578076089028121598550344376968358225755056849060375981974478849098945087519971168073531374196977105208304879275473249566439319959381378193928601404302247638661196533734272630600814429319138350227900384509506222905308341971979186947425519911
#put the first ciphertext here
rem[0] = 70532702661706167890859877997371007276988856318339813821969537524428266326504669477070760836591683492705945202125260479709294887786517662375229546627722684960708679755271540180339082167738729017891786945463574672698602848298989362453178123005156463346835632865575274622403875775603255014304408885861155801362
#put the second modulus here
num[1] = 92629677957692981976713776010462559714996285454056037348648884205035030518614357189081035607420478026647254856944016800480801066374296632340705745661215789336711368260385738421062856694928822952505996879927591818261842349862490964843539660382381860106527211408680710937025007270030105811711518602544148466807
#put the second ciphertext here
rem[1] = 48536443234700218963086199579612631203694527485268834596458116051989289883008903642474640986981657675640655509694020237620599280411153521629460749338421408302210356447315242535215859587519423805298727801435351524865010037331325707546161484151741379507006735932759075256358512118898280302018847672275146255492
#put the third modulus here
num[2] = 85329033449618608108507964089134878347417412447615704674475147015755619420897155323888094050574033636273704978399419445583528034870356814916928919096291096811658637221699939527829805578006713205625374508545817277896171145218594199065522064927749204066539610870985057893886772566680826875939414121567948603891
#put the third ciphertext here
rem[2] = 37299978314391364505263260265538910643323769703280854308581764743317519463029288393972173302017308085415377808418701915038849127388281256223923463644961767086034343276193047840970348673014594153669711545209664064933843187033436428100916802277441378681203138945091298389726760222966942362076946776706600528506

print(long_to_bytes(find_invpow(decimal.Decimal(findMinX(num, rem, k)),3)).decode('utf-8'))